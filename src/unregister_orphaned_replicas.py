#!/bin/python3
# 2024 by Ton Smeele, Utrecht University

import sys
import time
import argparse

import icat
import pathdb
from drrods_common import *
import drrods_sql


def is_modified_last_24h(epoch_time):
    one_day = 86400  # seconds
    return time.time() - epoch_time < one_day 

def is_in_flight(replica_status):
    return not replica_status in [0, 1]


def unreg_cmd(replica, scope = 'replica', options='--dryrun'):
    """
    Returns a commandline to unregister the replica.
    For data objects that have just 1 replica, scope='object' should be used.
    """
    #     because scope 'replica' is likely to be unsuccessful in such case.
    #     (iunreg command execution returns -402000 USER_INCOMPATIBLE_PARAMS)
    
    (data_id, coll_name, data_name, data_repl_num, data_is_dirty, create_ts, modify_ts) = replica

    # We add '--age' to make sure that we will not touch any replica that has been
    # modified very recently (within the last day)
    #
    # This mitigates, to some degree, a potential race condition where our output file 
    # is not yet applied as a bash script and a user updates the replica.
    
    obj = bash_squote(coll_name + '/' + data_name)
    age = 1440   # minutes, hence 1 day
    if scope == 'object':
        return "iunreg --age {} {} {}".format(age, options, obj)

    return "iunreg -n {} -N 0 --age {} {} {}".format(data_repl_num, age, options, obj) 





def main(args):
    db = load_dict(args.inputfile, SIGNATURE_ORPHAN_REPLICAS)
    if not db:
        sys.exit(1)

    print_stderr("{} orphan replicas have been loaded from the inputfile".format(db['replica_data_paths'].size()))

    connection = icat.Icat()
    if not connection.is_connected():
        print_stderr('Error: Unable to connect to ICAT database')
        sys.exit(1)

    options = '--dryrun'
    if cmd.dryrun is False:
        options = ''

    unprocessed = 0
    processed = 0
    with open_w(cmd.outputfile) as f:
        f.write('#/bin/bash\n#generated by DrRods tooling\n# Disclaimer: Use at own risk\n')
        for replica_data_path in db['replica_data_paths'].iter():
            replicas = drrods_sql.find_replicas_by_data_path(connection, db['host'], replica_data_path)
            for r in replicas:
                (data_id, coll_name, data_name, data_repl_num, data_is_dirty, create_ts, modify_ts) = r
                # ensure that the replica meets our preconditions before adding it to the unreg list
                if is_modified_last_24h(int(modify_ts)) or is_in_flight(int(data_is_dirty)):
                    unprocessed = unprocessed + 1
                    continue
                # we can unreg the replica
                count = drrods_sql.count_replicas(connection, data_id)
                scope = 'replica'
                if count == 1 :
                    scope = 'object'
                f.write(unreg_cmd(r, scope, options) + '\n')
                processed = processed + 1

    print_stderr("Output bash command file written to {}".format(cmd.outputfile))

    if unprocessed > 0 :
        print_stderr("\n{} replicas have been skipped because they were recently modified".format(unprocessed))



if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Prepares iunreg commands for replicas that reference a non-existing data file')
    parser.add_argument('inputfile', metavar='<inputfile.bin>', 
            help='file with paths of non-existing data files, used to select replicas that reference them') 
    parser.add_argument('outputfile',nargs='?', metavar='<filename>|"-"',
            help='bash commands to iunreg replicas will be written to this file')
    parser.add_argument('-d','--dryrun', action='store_true', dest='dryrun',
            help='produce an outputfile that can be executed as a dry-run')
    cmd = parser.parse_args()
    if not cmd.outputfile:
        cmd.outputfile = '-'
    main(cmd)



